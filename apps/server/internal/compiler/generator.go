package compiler

import (
	"encoding/json"
	"fmt"
	"strings"
)

// Raw canvas payload (React Flow)
type graphData struct {
	Nodes []graphNode `json:"nodes"`
	Edges []graphEdge `json:"edges"`
}

type graphNode struct {
	ID   string        `json:"id"`
	Data graphNodeData `json:"data"`
}

type graphNodeData struct {
	Name    string       `json:"name"`
	Label   string       `json:"label"`
	Columns []ColumnData `json:"columns"`
}

type ColumnData struct {
	ID           string   `json:"id"`
	Name         string   `json:"name"`
	Type         string   `json:"type"`
	IsPrimaryKey bool     `json:"isPrimaryKey"`
	IsUnique     bool     `json:"isUnique"`
	IsNullable   bool     `json:"isNullable"`
	Constraints  []string `json:"constraints"`
}

type graphEdge struct {
	Source       string `json:"source"`
	Target       string `json:"target"`
	SourceHandle string `json:"sourceHandle"`
	TargetHandle string `json:"targetHandle"`
}

// Normalized structures used by both standard and AI generators
type Schema struct {
	Tables    []TableSchema    `json:"tables"`
	Relations []RelationSchema `json:"relations"`
}

type TableSchema struct {
	ID      string         `json:"id"`
	Name    string         `json:"name"`
	Columns []ColumnSchema `json:"columns"`
}

type ColumnSchema struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	Type        string `json:"type"`
	NotNull     bool   `json:"notNull"`
	IsUnique    bool   `json:"isUnique"`
	IsPrimary   bool   `json:"isPrimary"`
	DisplayType string `json:"displayType"`
}

type RelationSchema struct {
	FromTable  string `json:"fromTable"`
	FromColumn string `json:"fromColumn"`
	ToTable    string `json:"toTable"`
	ToColumn   string `json:"toColumn"`
}

func GenerateSQL(jsonData []byte) (string, error) {
	schema, err := BuildSchema(jsonData)
	if err != nil {
		return "", err
	}

	var sb strings.Builder
	sb.WriteString("-- Generated by Skyforge\n\n")

	for _, table := range schema.Tables {
		tableName := cleanName(table.Name)
		sb.WriteString(fmt.Sprintf("CREATE TABLE %s (\n", tableName))

		pkCols := []string{}
		for i, col := range table.Columns {
			colName := cleanName(col.Name)
			colType := fallbackType(col.Type)

			colDef := fmt.Sprintf("  %s %s", colName, colType)
			if col.NotNull || col.IsPrimary {
				colDef += " NOT NULL"
			}
			if col.IsUnique && !col.IsPrimary {
				colDef += " UNIQUE"
			}

			if i < len(table.Columns)-1 || len(pkCols) > 0 {
				colDef += ","
			}
			sb.WriteString(colDef + "\n")

			if col.IsPrimary {
				pkCols = append(pkCols, colName)
			}
		}

		if len(pkCols) > 0 {
			sb.WriteString(fmt.Sprintf("  PRIMARY KEY (%s)\n", strings.Join(pkCols, ", ")))
		}

		sb.WriteString(");\n\n")
	}

	indexes := make(map[string]struct{})
	for _, rel := range schema.Relations {
		constraint := fmt.Sprintf(
			"fk_%s_%s_%s",
			cleanName(rel.ToTable),
			cleanName(rel.FromTable),
			cleanName(rel.FromColumn),
		)

		sb.WriteString(fmt.Sprintf(
			"ALTER TABLE %s\n  ADD CONSTRAINT %s\n  FOREIGN KEY (%s) REFERENCES %s(%s);\n\n",
			cleanName(rel.ToTable),
			constraint,
			cleanName(rel.ToColumn),
			cleanName(rel.FromTable),
			cleanName(rel.FromColumn),
		))

		if targetCol := findColumn(schema.Tables, rel.ToTable, rel.ToColumn); targetCol != nil && !targetCol.IsPrimary {
			idxName := fmt.Sprintf("idx_%s_%s_fk", cleanName(rel.ToTable), cleanName(rel.ToColumn))
			if _, exists := indexes[idxName]; !exists {
				sb.WriteString(fmt.Sprintf(
					"CREATE INDEX %s ON %s (%s);\n\n",
					idxName,
					cleanName(rel.ToTable),
					cleanName(rel.ToColumn),
				))
				indexes[idxName] = struct{}{}
			}
		}
	}

	return sb.String(), nil
}

// BuildSchema normalizes the raw canvas JSON into a deterministic structure that
// can be reused by code and AI generators.
func BuildSchema(jsonData []byte) (*Schema, error) {
	var graph graphData
	if err := json.Unmarshal(jsonData, &graph); err != nil {
		return nil, err
	}

	schema := &Schema{
		Tables:    make([]TableSchema, 0, len(graph.Nodes)),
		Relations: []RelationSchema{},
	}

	tableMap := make(map[string]*TableSchema)
	columnMap := make(map[string]ColumnSchema)

	for _, node := range graph.Nodes {
		tableName := strings.TrimSpace(node.Data.Name)
		if tableName == "" {
			tableName = strings.TrimSpace(node.Data.Label)
		}
		if tableName == "" {
			tableName = fmt.Sprintf("table_%s", node.ID)
		}

		table := TableSchema{
			ID:      node.ID,
			Name:    tableName,
			Columns: make([]ColumnSchema, 0, len(node.Data.Columns)),
		}

		for _, col := range node.Data.Columns {
			if strings.TrimSpace(col.Name) == "" {
				continue
			}

			column := ColumnSchema{
				ID:          col.ID,
				Name:        col.Name,
				Type:        fallbackType(col.Type),
				NotNull:     isNotNull(col),
				IsUnique:    col.IsUnique || hasConstraint(col, "UNQ"),
				IsPrimary:   col.IsPrimaryKey,
				DisplayType: displayType(col),
			}

			table.Columns = append(table.Columns, column)
			columnMap[columnKey(node.ID, col.ID)] = column
		}

		tableMap[node.ID] = &table
		schema.Tables = append(schema.Tables, table)
	}

	for _, edge := range graph.Edges {
		sourceTable, okSource := tableMap[edge.Source]
		targetTable, okTarget := tableMap[edge.Target]
		if !okSource || !okTarget {
			continue
		}

		sourceCol, okSourceCol := columnMap[columnKey(edge.Source, normalizeHandle(edge.SourceHandle))]
		targetCol, okTargetCol := columnMap[columnKey(edge.Target, normalizeHandle(edge.TargetHandle))]
		if !okSourceCol || !okTargetCol {
			continue
		}

		schema.Relations = append(schema.Relations, RelationSchema{
			FromTable:  sourceTable.Name,
			FromColumn: sourceCol.Name,
			ToTable:    targetTable.Name,
			ToColumn:   targetCol.Name,
		})
	}

	return schema, nil
}

func cleanName(s string) string {
	s = strings.TrimSpace(s)
	if s == "" {
		return "unnamed"
	}
	return strings.ReplaceAll(s, " ", "_")
}

func fallbackType(t string) string {
	t = strings.TrimSpace(t)
	if t == "" {
		return "text"
	}
	return t
}

func columnKey(nodeID, columnID string) string {
	return fmt.Sprintf("%s:%s", nodeID, columnID)
}

func normalizeHandle(handle string) string {
	if handle == "" {
		return handle
	}
	handle = strings.TrimSuffix(handle, "-source")
	handle = strings.TrimSuffix(handle, "-target")
	return handle
}

func hasConstraint(col ColumnData, code string) bool {
	code = strings.ToUpper(code)
	for _, c := range col.Constraints {
		if strings.EqualFold(c, code) {
			return true
		}
	}
	return false
}

func isNotNull(col ColumnData) bool {
	if col.IsPrimaryKey {
		return true
	}
	if hasConstraint(col, "NN") {
		return true
	}
	return !col.IsNullable
}

func displayType(col ColumnData) string {
	switch {
	case col.IsPrimaryKey:
		return "primary_key"
	case hasConstraint(col, "UNQ") || col.IsUnique:
		return "unique"
	case isNotNull(col):
		return "not_null"
	default:
		return "regular"
	}
}

func findColumn(tables []TableSchema, tableName, columnName string) *ColumnSchema {
	for ti := range tables {
		if !strings.EqualFold(tables[ti].Name, tableName) {
			continue
		}
		for ci := range tables[ti].Columns {
			if strings.EqualFold(tables[ti].Columns[ci].Name, columnName) {
				return &tables[ti].Columns[ci]
			}
		}
	}
	return nil
}
