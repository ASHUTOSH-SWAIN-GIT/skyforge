package compiler

import (
	"encoding/json"
	"fmt"
	"strings"
)

type GraphData struct {
	Nodes []Node `json:"nodes"`
	Edges []Edge `json:"edges"`
}

type Node struct {
	ID   string   `json:"id"`
	Data NodeData `json:"data"`
}

type NodeData struct {
	Label   string       `json:"label"`
	Columns []ColumnData `json:"columns"`
}

type ColumnData struct {
	ID           string `json:"id"`
	Name         string `json:"name"`
	Type         string `json:"type"`
	IsPrimaryKey bool   `json:"isPrimaryKey"`
	IsUnique     bool   `json:"isUnique"`
	IsNullable   bool   `json:"isNullable"`
}

type Edge struct {
	Source       string `json:"source"`
	Target       string `json:"target"`
	SourceHandle string `json:"sourceHandle"`
	TargetHandle string `json:"targetHandle"`
}

func GenerateSQL(jsonData []byte) (string, error) {
	var graph GraphData
	if err := json.Unmarshal(jsonData, &graph); err != nil {
		return "", err
	}

	var sb strings.Builder
	sb.WriteString("-- Generated by Skyforge\n\n")

	tableMap := make(map[string]Node)
	columnMap := make(map[string]ColumnData)

	for _, node := range graph.Nodes {
		tableMap[node.ID] = node

		tableName := cleanName(node.Data.Label)
		sb.WriteString(fmt.Sprintf("CREATE TABLE %s (\n", tableName))

		primaryKeys := []string{}

		for i, col := range node.Data.Columns {
			key := fmt.Sprintf("%s:%s", node.ID, col.ID)
			columnMap[key] = col

			colName := cleanName(col.Name)
			colDef := fmt.Sprintf("  %s %s", colName, col.Type)

			if !col.IsNullable {
				colDef += " NOT NULL"
			}
			if col.IsUnique {
				colDef += " UNIQUE"
			}
			if col.IsPrimaryKey {
				primaryKeys = append(primaryKeys, colName)
			}

			if i < len(node.Data.Columns)-1 || len(primaryKeys) > 0 {
				colDef += ","
			}
			sb.WriteString(colDef + "\n")
		}

		if len(primaryKeys) > 0 {
			pkStr := strings.Join(primaryKeys, ", ")
			sb.WriteString(fmt.Sprintf("  PRIMARY KEY (%s)\n", pkStr))
		}

		sb.WriteString(");\n\n")
	}

	for _, edge := range graph.Edges {
		sourceNode, ok1 := tableMap[edge.Source]
		targetNode, ok2 := tableMap[edge.Target]

		sourceColKey := fmt.Sprintf("%s:%s", edge.Source, edge.SourceHandle)
		targetColKey := fmt.Sprintf("%s:%s", edge.Target, edge.TargetHandle)

		sourceCol, ok3 := columnMap[sourceColKey]
		targetCol, ok4 := columnMap[targetColKey]

		if ok1 && ok2 && ok3 && ok4 {
			tableName := cleanName(targetNode.Data.Label)
			constraintName := fmt.Sprintf("fk_%s_%s", tableName, cleanName(sourceNode.Data.Label))

			sb.WriteString(fmt.Sprintf("ALTER TABLE %s\n", tableName))
			sb.WriteString(fmt.Sprintf("  ADD CONSTRAINT %s\n", constraintName))
			sb.WriteString(fmt.Sprintf("  FOREIGN KEY (%s) REFERENCES %s(%s);\n\n",
				cleanName(targetCol.Name),
				cleanName(sourceNode.Data.Label),
				cleanName(sourceCol.Name),
			))
		}
	}

	return sb.String(), nil
}

func cleanName(s string) string {
	return strings.ReplaceAll(s, " ", "_")
}
