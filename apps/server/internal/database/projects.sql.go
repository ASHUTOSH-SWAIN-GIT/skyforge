// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: projects.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const addProjectCollaborator = `-- name: AddProjectCollaborator :exec
INSERT INTO project_collaborators (project_id, user_id, role)
VALUES ($1, $2, $3)
`

type AddProjectCollaboratorParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	UserID    uuid.UUID `json:"user_id"`
	Role      string    `json:"role"`
}

func (q *Queries) AddProjectCollaborator(ctx context.Context, arg AddProjectCollaboratorParams) error {
	_, err := q.db.ExecContext(ctx, addProjectCollaborator, arg.ProjectID, arg.UserID, arg.Role)
	return err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (user_id, name, description, data)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, name, description, data, is_public, last_saved_at, created_at, updated_at
`

type CreateProjectParams struct {
	UserID      uuid.UUID       `json:"user_id"`
	Name        string          `json:"name"`
	Description sql.NullString  `json:"description"`
	Data        json.RawMessage `json:"data"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, createProject,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.Data,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Data,
		&i.IsPublic,
		&i.LastSavedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT id, user_id, name, description, data, is_public, last_saved_at, created_at, updated_at FROM projects WHERE id = $1
`

func (q *Queries) GetProjectByID(ctx context.Context, id uuid.UUID) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProjectByID, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Data,
		&i.IsPublic,
		&i.LastSavedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectCollaborator = `-- name: GetProjectCollaborator :one
SELECT id, project_id, user_id, role, created_at
FROM project_collaborators
WHERE project_id = $1 AND user_id = $2
`

type GetProjectCollaboratorParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) GetProjectCollaborator(ctx context.Context, arg GetProjectCollaboratorParams) (ProjectCollaborator, error) {
	row := q.db.QueryRowContext(ctx, getProjectCollaborator, arg.ProjectID, arg.UserID)
	var i ProjectCollaborator
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.UserID,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const getProjectsByUser = `-- name: GetProjectsByUser :many
SELECT p.id, p.name, p.description, p.is_public, p.last_saved_at, p.created_at, 'owner' as role
FROM projects p
WHERE p.user_id = $1
UNION ALL
SELECT p.id, p.name, p.description, p.is_public, p.last_saved_at, p.created_at, pc.role
FROM projects p
JOIN project_collaborators pc ON p.id = pc.project_id
WHERE pc.user_id = $1
ORDER BY last_saved_at DESC
`

type GetProjectsByUserRow struct {
	ID          uuid.UUID      `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	IsPublic    bool           `json:"is_public"`
	LastSavedAt time.Time      `json:"last_saved_at"`
	CreatedAt   time.Time      `json:"created_at"`
	Role        string         `json:"role"`
}

func (q *Queries) GetProjectsByUser(ctx context.Context, userID uuid.UUID) ([]GetProjectsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getProjectsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectsByUserRow
	for rows.Next() {
		var i GetProjectsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IsPublic,
			&i.LastSavedAt,
			&i.CreatedAt,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeProjectCollaborator = `-- name: RemoveProjectCollaborator :exec
DELETE FROM project_collaborators
WHERE project_id = $1 AND user_id = $2
`

type RemoveProjectCollaboratorParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) RemoveProjectCollaborator(ctx context.Context, arg RemoveProjectCollaboratorParams) error {
	_, err := q.db.ExecContext(ctx, removeProjectCollaborator, arg.ProjectID, arg.UserID)
	return err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects 
SET name = $2,
    description = $3,
    data = $4,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, name, description, data, is_public, last_saved_at, created_at, updated_at
`

type UpdateProjectParams struct {
	ID          uuid.UUID       `json:"id"`
	Name        string          `json:"name"`
	Description sql.NullString  `json:"description"`
	Data        json.RawMessage `json:"data"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProject,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Data,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Data,
		&i.IsPublic,
		&i.LastSavedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProjectData = `-- name: UpdateProjectData :one
UPDATE projects
SET data = $2,
    updated_at = NOW(),
    last_saved_at = NOW()
WHERE id = $1
RETURNING id, user_id, name, description, data, is_public, last_saved_at, created_at, updated_at
`

type UpdateProjectDataParams struct {
	ID   uuid.UUID       `json:"id"`
	Data json.RawMessage `json:"data"`
}

func (q *Queries) UpdateProjectData(ctx context.Context, arg UpdateProjectDataParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProjectData, arg.ID, arg.Data)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Data,
		&i.IsPublic,
		&i.LastSavedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertProjectCollaborator = `-- name: UpsertProjectCollaborator :exec
INSERT INTO project_collaborators (project_id, user_id, role)
VALUES ($1, $2, $3)
ON CONFLICT (project_id, user_id) DO UPDATE
SET role = EXCLUDED.role
`

type UpsertProjectCollaboratorParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	UserID    uuid.UUID `json:"user_id"`
	Role      string    `json:"role"`
}

func (q *Queries) UpsertProjectCollaborator(ctx context.Context, arg UpsertProjectCollaboratorParams) error {
	_, err := q.db.ExecContext(ctx, upsertProjectCollaborator, arg.ProjectID, arg.UserID, arg.Role)
	return err
}
